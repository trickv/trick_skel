.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "App::SVN::Bisect 3pm"
.TH App::SVN::Bisect 3pm "2009-12-04" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
App::SVN::Bisect \- binary search through svn revisions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&    my $bisect = App::SVN::Bisect\->new(
\&        Action => $action,
\&        Min => $min,
\&        Max => $max
\&    );
\&    $bisect\->do_something_intelligent(@ARGV);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements the backend of the \*(L"svn-bisect\*(R" command line tool.  See
the \s-1POD\s0 documentation of that tool, for usage details.
.SH "API METHODS"
.IX Header "API METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&    $self = App::SVN::Bisect\->new(Action => "bad", Min => 0, Max => undef);
.Ve
.PP
Create an App::SVN::Bisect object.  The arguments are typically parsed from
the command line.
.PP
The Action argument must be listed in the \f(CW%actions\fR table.  The \*(L"read_config\*(R"
attribute of the action determines whether the metadata file (typically named
\&.svn/bisect.yaml) will be read.
.SS "do_something_intelligent"
.IX Subsection "do_something_intelligent"
.Vb 1
\&    $self\->do_something_intelligent(@ARGV);
.Ve
.PP
Executes the action specified by the user.  See the \*(L"Action methods\*(R" section,
below, for the details.
.PP
If the action's \*(L"write_config\*(R" bit is set in the \f(CW%actions\fR table, the metadata
file will be written after executing the action.  If the bit was not set, the
metadata file is removed.
.SH "ACTION METHODS"
.IX Header "ACTION METHODS"
.SS "start"
.IX Subsection "start"
Begins a bisect session.  Sets up the parameters, queries some stuff about the
subversion repository, and starts the user off with the first bisect.
.SS "before"
.IX Subsection "before"
Sets the \*(L"min\*(R" parameter to the specified (or current) revision, and
then moves the user to the middle of the resulting range.
.SS "after"
.IX Subsection "after"
Sets the \*(L"max\*(R" parameter to the specified (or current) revision, and
then moves the user to the middle of the resulting range.
.SS "reset"
.IX Subsection "reset"
Cleans up after a bisect session.  If \-\-back is passed, it also moves
the working tree back to the original revision it had when \*(L"start\*(R" was
first called.
.SS "skip"
.IX Subsection "skip"
Tells svn-bisect to ignore the specified (or current) revision, and
then moves the user to another, strategically useful revision.
.PP
You may specify as many revisions at once as you like.
.SS "unskip"
.IX Subsection "unskip"
Tells svn-bisect to stop ignoring the specified revision, then moves
the user to another, strategically useful revision.
.PP
You may specify as many revisions at once as you like.
.SS "run"
.IX Subsection "run"
Runs a command repeatedly to automate the bisection process.
.PP
We run the command and arguments until a conclusion is reached.  The
command (usually a shell script) tells us about the current revision
by way of its return code.  The following return codes are handled:
.PP
.Vb 4
\&    0: This revision is before the change we\*(Aqre looking for
\&    1\-124, 126\-127: This revision includes the change we\*(Aqre looking for
\&    125: This revision is untestable and should be skipped
\&    any other value: The command failed to run, abort bisection.
.Ve
.PP
The normal caveats apply.  In particular, if your script makes any
changes, don't forget to clean up afterwards.
.SS "help"
.IX Subsection "help"
Allows the user to get some descriptions and usage information.
.PP
This function calls \fIexit()\fR directly, to prevent \fIdo_something_intelligent()\fR
from removing the metadata file.
.SS "view"
.IX Subsection "view"
Allows the user to get some information about the current state of things.
.PP
This function calls \fIexit()\fR directly, to prevent \fIdo_something_intelligent()\fR
from removing the metadata file.
.SH "INTERNAL METHODS"
.IX Header "INTERNAL METHODS"
.SS "cmd"
.IX Subsection "cmd"
.Vb 1
\&    my $stdout = $self\->cmd("svn info");
.Ve
.PP
Runs a command, returns its output.
.SS "ready"
.IX Subsection "ready"
.Vb 1
\&    $self\->next_rev() if $self\->ready();
.Ve
.PP
Returns a true value if we have enough information to begin bisecting.
Specifically, this returns true if we have been given at least one \*(L"bad\*(R"
and one \*(L"good\*(R" revision.  These can be specified as arguments to the
\&\*(L"before\*(R" and \*(L"after\*(R" commands, or as \-\-min and \-\-max arguments to the
\&\*(L"start\*(R" command.
.SS "next_rev"
.IX Subsection "next_rev"
.Vb 1
\&    $self\->next_rev();
.Ve
.PP
Find a spot in the middle of the current \*(L"suspect revisions\*(R" list, and calls
\&\*(L"svn update\*(R" to move the checkout directory to that revision.
.SS "list_revs"
.IX Subsection "list_revs"
.Vb 1
\&    my @revs = $self\->list_revs();
.Ve
.PP
Returns the set of valid revisions between the current \*(L"min\*(R" and \*(L"max\*(R" values,
exclusive.
.PP
This is smart about revisions that don't affect the current tree (because they
won't be returned by fetch_log_revs, below) and about skipped revisions (which
the user may specify with the \*(L"skip\*(R" command).
.SS "stdout"
.IX Subsection "stdout"
.Vb 1
\&    $self\->stdout("Hello, world!\en");
.Ve
.PP
Output a message to stdout.  This is basically just the \*(L"print\*(R" function, but
we use a method so the testsuite can override it through subclassing.
.SS "verbose"
.IX Subsection "verbose"
.Vb 1
\&    $self\->verbose("Hello, world!\en");
.Ve
.PP
Output a message to stdout, if the user specified the \-\-verbose option.  This
is basically just a conditional wrapper around the \*(L"print\*(R" function.
.SS "exit"
.IX Subsection "exit"
.Vb 1
\&    $self\->exit(0);
.Ve
.PP
Exits.  This allows the test suite to override exiting; it does not
provide any other features above and beyond what the normal exit
system call provides.
.SH "SUBVERSION ACCESSOR METHODS"
.IX Header "SUBVERSION ACCESSOR METHODS"
.SS "update_to"
.IX Subsection "update_to"
.Vb 1
\&    $self\->update_to(25000);
.Ve
.PP
Calls 'svn update' to move to the specified revision.
.SS "fetch_log_revs"
.IX Subsection "fetch_log_revs"
.Vb 1
\&    my $hashref = $self\->fetch_log_revs();
.Ve
.PP
Calls \*(L"svn log\*(R" and parses the output.  Returns a hash reference whose keys
are valid revision numbers; so you can use \fIexists()\fR to find out whether a
number is in the list.  This hash reference is used by \fIlist_revs()\fR, above.
.SS "find_max"
.IX Subsection "find_max"
.Vb 1
\&    my $rev = $self\->find_max();
.Ve
.PP
Plays some tricks with \*(L"svn log\*(R" to figure out the latest revision contained
within the repository.
.SS "find_cur"
.IX Subsection "find_cur"
.Vb 1
\&    my $rev = $self\->find_cur();
.Ve
.PP
Parses the output of \*(L"svn info\*(R" to figure out what the current revision is.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 1
\&    Mark Glines <mark\-cpan@glines.org>
.Ve
.SH "THANKS"
.IX Header "THANKS"
* Thanks to the git-bisect author(s), for coming up with a user interface that
I actually like.
.PP
* Thanks to Will Coleda for inspiring me to actually write and release this.
.PP
* Thanks to the Parrot project for having so much random stuff going on as to
make a tool like this necessary.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
App::SVNBinarySearch by Will Coleda: <http://search.cpan.org/dist/App\-SVNBinarySearch/>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2008\-2009 Mark Glines.
.PP
It is distributed under the terms of the Artistic License 2.0.  For details,
see the \*(L"\s-1LICENSE\s0\*(R" file packaged alongside this module.
